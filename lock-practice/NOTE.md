## 分布式锁

#### 分布式系统简介
&emsp;&emsp;由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。  
&emsp;&emsp;目的是利用更多的机器，处理更多的数据。
---
#### 分布式锁简介
&emsp;&emsp;单机情况下，采用线程加锁的机制，即当某个线程获取到这个资源后，需要对该资源进行加锁，使用完之后再解锁。(synchronize/Lock)  
&emsp;&emsp;分布式锁是控制分布式系统之间同步访问资源的一种方式。不同系统或者同一系统不同主机之间共享了一个或一组资源，访问资源时就需要互斥来防止彼此干扰保证数据的一致性
---
#### 分布式锁要满足的要求？
* **排他性**：在同一时间只有一个客户端能获取到锁
* **避免死锁**：锁在一定有限的时间之后，一定会被释放（正常释放或异常释放）
* **高可用**：获取或者释放锁的机制必须高可用性能佳
---
#### 分布式锁实现方式
* **数据库**
* **Redis**
* **Zookeeper**  
---
#### 基于数据库实现
**1. 乐观锁**  
&emsp;&emsp;认为拿锁很可能是成功的，在进行完业务操作需要实际更新数据的最后一步再去拿锁。  
&emsp;&emsp;乐观锁机制是在数据库表中引入一个版本号（version）字段来实现的。当我们要从数据库中读取数据的时候，同时把这个version字段读取出来，进行更新后version加1写回数据库。所以必须在更新的时候同时检查数据库里面的version还是不是之前的version。如果不是则更新失败，说明过程中有其他的进程更新过数据了。  
**2. 悲观锁**  
&emsp;&emsp;认为拿锁很可能是失败的，先确保获取锁成功之后再进行业务操作。  
&emsp;&emsp;“一锁二查三更新”，数据库上的悲观锁需要数据库本身提供支持，即通过`select ... for update`操作来实现悲观锁。当数据库执行`select for update`时会获取被`select`中的数据行的行锁，因此如果其他并发执行的`select for update`如果试图选中同一行则会发生排斥。获取的行锁会在当前事务结束时自动释放，**因此必须要事务中使用**。
---
#### 基于Redis实现
&emsp;&emsp;基于redis实现的锁机制，主要是依赖redis自身的原子操作，例如：  
&emsp;&emsp;&emsp;`SET user_key user_value NX PX 100`  
* NX：只在键不存在时，才对键进行设置操作，`SET key value NX`效果等同于`SETNX key value`
* PX millisecond：设置键的过期时间为毫秒，当超过这个时间后，设置的键自动失效  
&emsp;**$\color{red}{总结：}$**当redis中不存在user_key这个键的时候，才会去设置一个user_key键，并且给这个键的值设置为 user_value，且这个键的存活时间为100ms

**为什么这个命令可以帮我们实现锁机制呢？**  
&emsp;&emsp;因为这个命令是只有在某个key不存在的时候，才会被执行成功。那么当多个进程同时并发的去设置同一个key的时候，就永远只会有一个进程成功。当某个进程设置成功之后，就可以去执行业务逻辑了，等业务逻辑执行完毕之后再去解锁。  
&emsp;&emsp;解锁只需要删除这个key就可以了，不过删除之前需要判断这个key对应的value是不是自己设置的哪个  
&emsp;&emsp;针对redis集群集群的分布式锁，可以采用redis的RedLock（可能会被墙）机制。
---
#### 基于Zookeeper实现  
&emsp;&emsp;使用它的临时有序节点来实现分布式锁
**原理**
&emsp;&emsp;当某客户端要进行逻辑的加锁时，就在Zookeeper上的某个指定节点下的目录下，去生成一个唯一的临时有序节点，然后判断自己是否这些节点中序号最小的一个。如果是，则算是获取了锁。如果不是，则说明没有获取到锁，那么就需要在序列中找到找到比自己小的哪个节点，并对其调用`exist()`方法，对其进行注册事件监听，当监听的节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，重复上述操作。  
&emsp;&emsp;当释放锁的时候，只需要将这个临时节点删除即可。  
&emsp;&emsp;![avatar](/image/zookeeper.png)  
&emsp;&emsp;如上图，locker是一个持久节点，`node_1/node_2/.../node_n` 就是上面说的临时节点，由客户端client去创建的  
&emsp;&emsp;`client_1/client_2/.../client_n` 都是想去获取锁的客户端以client_1为例，它想去获取分布式锁，则需要跑到locker下面去创建临时节点（假如是node_1）创建完毕后，看一下自己的节点序号是否是locker下面最小的，如果是，则获取了锁。如果不是，则去找到比自己小的那个节点（假如是node_2），找到后，就监听node_2，直到node_2被删除，那么就开始再次判断自己的node_1是不是序列中最小的，如果是，则获取锁，如果还不是，则继续找一下一个节点。  
